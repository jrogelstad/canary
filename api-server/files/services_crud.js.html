<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>services\crud.js - Featherbone Server</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="..\..\featherbone-server.png" title="Featherbone Server"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Client.html">Client</a></li>
                                <li><a href="../classes/Connection.html">Connection</a></li>
                                <li><a href="../classes/Database.html">Database</a></li>
                                <li><a href="../classes/Datasource.html">Datasource</a></li>
                                <li><a href="../classes/f.html">f</a></li>
                                <li><a href="../classes/Money.html">Money</a></li>
                                <li><a href="../classes/Services.API.html">Services.API</a></li>
                                <li><a href="../classes/Services.CRUD.html">Services.CRUD</a></li>
                                <li><a href="../classes/Services.Currency.html">Services.Currency</a></li>
                                <li><a href="../classes/Services.Events.html">Services.Events</a></li>
                                <li><a href="../classes/Services.Exporter.html">Services.Exporter</a></li>
                                <li><a href="../classes/Services.Feathers.html">Services.Feathers</a></li>
                                <li><a href="../classes/Services.Importer.html">Services.Importer</a></li>
                                <li><a href="../classes/Services.Installer.html">Services.Installer</a></li>
                                <li><a href="../classes/Services.Packager.html">Services.Packager</a></li>
                                <li><a href="../classes/Services.Profile.html">Services.Profile</a></li>
                                <li><a href="../classes/Services.Role.html">Services.Role</a></li>
                                <li><a href="../classes/Services.Routes.html">Services.Routes</a></li>
                                <li><a href="../classes/Services.Services.html">Services.Services</a></li>
                                <li><a href="../classes/Services.Settings.html">Services.Settings</a></li>
                                <li><a href="../classes/Services.Tools.html">Services.Tools</a></li>
                                <li><a href="../classes/Services.Workbooks.html">Services.Workbooks</a></li>
                                <li><a href="../classes/String.html">String</a></li>
                                <li><a href="../classes/User.html">User</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/API.html">API</a></li>
                                <li><a href="../modules/CRUD.html">CRUD</a></li>
                                <li><a href="../modules/Currency.html">Currency</a></li>
                                <li><a href="../modules/Database.html">Database</a></li>
                                <li><a href="../modules/Datasource.html">Datasource</a></li>
                                <li><a href="../modules/Events.html">Events</a></li>
                                <li><a href="../modules/Feathers.html">Feathers</a></li>
                                <li><a href="../modules/Installer.html">Installer</a></li>
                                <li><a href="../modules/IO.html">IO</a></li>
                                <li><a href="../modules/Packager.html">Packager</a></li>
                                <li><a href="../modules/Profile.html">Profile</a></li>
                                <li><a href="../modules/Role.html">Role</a></li>
                                <li><a href="../modules/Routes.html">Routes</a></li>
                                <li><a href="../modules/Settings.html">Settings</a></li>
                                <li><a href="../modules/Tools.html">Tools</a></li>
                                <li><a href="../modules/Workbooks.html">Workbooks</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: services\crud.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
    Framework for building object relational database apps
    Copyright (C) 2019  John Rogelstad

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
*/
/*jslint node, for*/
/**
    Create, read, update and delete methods for persisting data to the
    database.
    @module CRUD
*/
(function (exports) {
    &quot;use strict&quot;;

    const {Currency} = require(&quot;./currency&quot;);
    const {Database} = require(&quot;../database&quot;);
    const {Events} = require(&quot;./events&quot;);
    const {Feathers} = require(&quot;./feathers&quot;);
    const {Tools} = require(&quot;./tools&quot;);

    const currency = new Currency();
    const db = new Database();
    const events = new Events();
    const feathers = new Feathers();
    const tools = new Tools();
    const formats = tools.formats;
    const f = require(&quot;../../common/core&quot;);
    const jsonpatch = require(&quot;fast-json-patch&quot;);

    /**
        Return a promise that resolves money object with
        zero amount and base currency. Used as currency
        default.

        @method money
        @for f
        @return {Promise} Resolves to {{#crossLink &quot;Money&quot;}}{{/crossLink}}
    */
    f.money = function () {
        return new Promise(function (resolve, reject) {
            function callback(baseCurr) {
                resolve({
                    amount: 0,
                    currency: baseCurr.code,
                    effective: null,
                    baseAmount: null
                });
            }

            currency.baseCurrency({data: {}}).then(
                callback
            ).catch(
                reject
            );
        });
    };

    /**
        Services for create, read, update and delete actions.

        @class CRUD
        @constructor
        @namespace Services
    */
    exports.CRUD = function () {
        // ..........................................................
        // PRIVATE
        //

        const crud = {};

        // ..........................................................
        // PUBLIC
        //

        /**
            Perform soft delete on object records.

            @method doDelete
            @param {Object} payload Request payload
            @param {String} payload.id Id of record to delete
            @param {String | Object} payload.client Database client
            @param {Boolean} [payload.isHard] Hard delete flag. Default false.
            @param {Boolean} [isChild] Request as child. Default false.
            @param {Boolean} [isSuperUser] Request as super user. Default false.
            @return {Promise} Resolves &#x60;true&#x60; if successful
        */
        crud.doDelete = function (obj, isChild, isSuperUser) {
            return new Promise(function (resolve, reject) {
                let oldRec;
                let keys;
                let props;
                let noChildProps;
                let afterGetFeather;
                let afterAuthorization;
                let afterDoSelect;
                let afterDelete;
                let afterLog;
                let sql = &quot;UPDATE object SET is_deleted = true WHERE id=$1;&quot;;
                let clen = 1;
                let c = 0;
                let client = db.getClient(obj.client);

                if (obj.isHard === true) {
                    sql = &quot;DELETE FROM object WHERE id=$1;&quot;;
                }

                noChildProps = function (key) {
                    let t = props[key].type;

                    if (typeof t !== &quot;object&quot; || !t.childOf) {
                        return true;
                    }
                };

                afterGetFeather = function (feather) {
                    props = feather.properties;

                    if (!isChild &amp;&amp; feather.isChild) {
                        reject(&quot;Can not directly delete a child class&quot;);
                        return;
                    }

                    if (isSuperUser === false) {
                        feathers.isAuthorized({
                            client: client,
                            data: {
                                id: obj.id,
                                action: &quot;canDelete&quot;
                            }
                        }).then(afterAuthorization).catch(reject);
                        return;
                    }

                    afterAuthorization(true);
                };

                afterAuthorization = function (authorized) {
                    if (!authorized) {
                        reject(&quot;Not authorized to delete \&quot;&quot; + obj.id + &quot;\&quot;&quot;);
                        return;
                    }

                    // Get old record, bail if it doesn&#x27;t exist
                    // Exclude childOf relations when we select
                    crud.doSelect({
                        name: obj.name,
                        id: obj.id,
                        showDeleted: true,
                        properties: Object.keys(props).filter(noChildProps),
                        client: client,
                        callback: afterDoSelect
                    }, true).then(afterDoSelect).catch(reject);
                };

                afterDoSelect = function (resp) {
                    let eventKey = &quot;_eventkey&quot;; // JSLint no underscore
                    let msg;

                    oldRec = resp;

                    if (!oldRec) {
                        reject(&quot;Record &quot; + obj.id + &quot; not found.&quot;);
                        return;
                    }

                    if (oldRec.isDeleted) {
                        reject(&quot;Record &quot; + obj.id + &quot; already deleted.&quot;);
                        return;
                    }

                    if (
                        oldRec &amp;&amp; oldRec.lock &amp;&amp;
                        oldRec.lock[eventKey] !== obj.eventkey
                    ) {
                        msg = &quot;Record is locked by &quot; + oldRec.lock.username;
                        msg += &quot; and cannot be updated.&quot;;
                        reject(new Error(msg));
                        return;
                    }

                    // Get keys for properties of child arrays.
                    // Count expected callbacks along the way.
                    keys = Object.keys(props).filter(function (key) {
                        if (
                            typeof props[key].type === &quot;object&quot; &amp;&amp;
                            props[key].type.parentOf
                        ) {
                            clen += oldRec[key].length;
                            return true;
                        }
                    });

                    // Delete children recursively
                    keys.forEach(function (key) {
                        let rel = props[key].type.relation;
                        oldRec[key].forEach(function (row) {
                            crud.doDelete({
                                name: rel,
                                id: row.id,
                                client: client,
                                isHard: obj.isHard
                            }, true).then(afterDelete).catch(reject);
                        });
                    });

                    // Finally, delete parent object
                    client.query(sql, [obj.id], afterDelete);
                };

                // Handle change log
                afterDelete = function () {
                    let now = f.now();

                    // Move on only after all callbacks report back
                    c += 1;
                    if (c &lt; clen) {
                        return;
                    }

                    if (isChild || obj.isHard) {
                        afterLog();
                        return;
                    }

                    // Log the completed deletion
                    crud.doInsert({
                        name: &quot;Log&quot;,
                        data: {
                            objectId: obj.id,
                            action: &quot;DELETE&quot;,
                            created: now,
                            createdBy: now,
                            updated: now,
                            updatedBy: now
                        },
                        client: client
                    }, true).then(afterLog).catch(reject);
                };

                afterLog = function () {
                    resolve(true);
                };

                // Kick off query by getting feather, the rest falls
                // through callbacks
                feathers.getFeather({
                    client: client,
                    data: {
                        name: obj.name
                    }
                }).then(afterGetFeather).catch(reject);
            });
        };

        /**
            Insert records for a passed object.

            @method doInsert
            @param {Object} payload Request payload
            @param {String} payload.name Object type name
            @param {Object} payload.data Data to insert
            @param {String | Object} payload.client Database client
            @param {Boolean} [isChild] Request as child. Default false.
            @param {Boolean} [isSuperUser] Request as super user. Default false.
            @return {Promise} Resolves to array of patches reporting back
            differences between request and actual saved record result.
        */
        crud.doInsert = function (obj, isChild, isSuperUser) {
            return new Promise(function (resolve, reject) {
                let sql;
                let col;
                let key;
                let child;
                let pk;
                let n;
                let dkeys;
                let fkeys;
                let len;
                let msg;
                let props;
                let prop;
                let value;
                let result;
                let afterGetFeather;
                let afterIdCheck;
                let afterNextVal;
                let afterAuthorized;
                let buildInsert;
                let afterGetPk;
                let afterHandleRelations;
                let insertChildren;
                let afterInsert;
                let afterDoSelect;
                let afterLog;
                let afterUniqueCheck;
                let feather;
                let payload;
                let data = f.copy(obj.data);
                let name = obj.name || &quot;&quot;;
                let args = [name.toSnakeCase()];
                let tokens = [];
                let params = [];
                let values = [];
                let unique = false;
                let clen = 1;
                let c = 0;
                let p = 2;
                let client = db.getClient(obj.client);

                payload = {
                    data: {
                        name: obj.name
                    },
                    client: client
                };

                afterGetFeather = function (resp) {
                    if (!resp) {
                        reject(&quot;Class \&quot;&quot; + name + &quot;\&quot; not found&quot;);
                        return;
                    }

                    feather = resp;
                    props = feather.properties;
                    fkeys = Object.keys(props);
                    dkeys = Object.keys(data);

                    /* Validate properties are valid */
                    len = dkeys.length;
                    for (n = 0; n &lt; len; n += 1) {
                        if (fkeys.indexOf(dkeys[n]) === -1) {
                            msg = &quot;Feather \&quot;&quot; + name;
                            msg += &quot;\&quot; does not contain property \&quot;&quot;;
                            msg += dkeys[n] + &quot;\&quot;&quot;;
                            reject(new Error(msg));
                            return;
                        }
                    }

                    /* Check id for existence and uniqueness and regenerate
                       if needed */
                    if (!data.id) {
                        afterIdCheck(null, -1);
                        return;
                    }

                    tools.getKey({
                        id: data.id,
                        client: client
                    }, true).then(afterIdCheck).catch(reject);
                };

                afterIdCheck = function (id) {
                    if (id !== undefined) {
                        data.id = f.createId();
                    }

                    Object.keys(feather.properties).some(function (key) {
                        let fp = feather.properties[key];

                        if (fp.isNaturalKey &amp;&amp; !fp.autonumber) {
                            unique = {
                                feather: fp.inheritedFrom || feather.name,
                                prop: key,
                                value: obj.data[key],
                                label: fp.alias || key
                            };

                            return true;
                        }

                        return false;
                    });

                    if (unique) {
                        tools.getKeys({
                            client: client,
                            name: unique.feather,
                            filter: {
                                criteria: [{
                                    property: unique.prop,
                                    value: unique.value
                                }]
                            }
                        }).then(afterUniqueCheck).catch(reject);
                        return;
                    }

                    afterUniqueCheck();
                };

                afterUniqueCheck = function (resp) {
                    if (resp &amp;&amp; resp.length) {
                        msg = &quot;Value &#x27;&quot; + unique.value + &quot;&#x27; assigned to &quot;;
                        msg += unique.label.toName() + &quot; on &quot;;
                        msg += feather.name.toName();
                        msg += &quot; is not unique to data type &quot;;
                        msg += unique.feather.toName() + &quot;.&quot;;
                        reject(new Error(msg));
                        return;
                    }

                    if (!isChild &amp;&amp; isSuperUser === false) {
                        feathers.isAuthorized({
                            client: client,
                            data: {
                                feather: name,
                                action: &quot;canCreate&quot;
                            }
                        }).then(afterAuthorized).catch(reject);
                        return;
                    }

                    afterAuthorized(true);
                };

                afterAuthorized = function (authorized) {
                    if (!authorized) {
                        msg = &quot;Not authorized to create \&quot;&quot;;
                        msg += obj.name + &quot;\&quot;&quot;;
                        reject({
                            statusCode: 401,
                            message: msg
                        });
                        return;
                    }

                    // Set some system controlled values
                    data.updated = f.now();
                    data.created = data.updated;
                    data.createdBy = client.currentUser();
                    data.updatedBy = client.currentUser();
                    data.isDeleted = false;
                    data.lock = null;

                    // Get primary key
                    sql = &quot;select nextval(&#x27;object__pk_seq&#x27;)&quot;;
                    client.query(sql, afterNextVal);
                };

                afterNextVal = function (err, resp) {
                    if (err) {
                        reject(err);
                        return;
                    }

                    pk = resp.rows[0].nextval;
                    values.push(pk);

                    /* Build values */
                    len = fkeys.length;
                    n = 0;
                    buildInsert();
                };

                buildInsert = function () {
                    let callback;

                    if (n &lt; len) {
                        key = fkeys[n];
                        child = false;
                        prop = props[key];
                        n += 1;
                        value = undefined;

                        /* Handle relations */
                        if (typeof prop.type === &quot;object&quot;) {
                            if (prop.type.parentOf) {
                                /* To many */
                                child = true;

                                /* To one */
                            } else {
                                col = tools.relationColumn(
                                    key,
                                    prop.type.relation
                                );

                                if (
                                    data[key] === null ||
                                    data[key] === undefined
                                ) {
                                    if (
                                        prop.default !== undefined &amp;&amp; (
                                            prop.default !== null ||
                                            prop.type === &quot;object&quot; ||
                                            prop.type === &quot;array&quot; ||
                                            prop.format === &quot;date&quot; ||
                                            prop.format === &quot;dateTime&quot;
                                        )
                                    ) {
                                        data[key] = prop.default;
                                    } else if (prop.isRequired !== true) {
                                        value = -1;
                                    } else {
                                        msg = &quot;Property &quot; + key;
                                        msg += &quot; is required on &quot;;
                                        msg += feather.name + &quot;.&quot;;
                                        reject(new Error(msg));
                                        return;
                                    }
                                }
                                if (value !== -1) {
                                    if (prop.type.isChild) {
                                        /* Insert child relation on the fly */
                                        crud.doInsert({
                                            name: prop.type.relation,
                                            data: data[key],
                                            client: client
                                        }, true, true).then(function () {
                                            tools.getKey({
                                                id: data[key].id,
                                                client: client
                                            }).then(afterGetPk).catch(reject);
                                        }).catch(reject);
                                        return;
                                    }

                                    /* Relation must already exist */
                                    if (prop.type.childOf &amp;&amp; obj.pk) {
                                        afterGetPk(obj.pk);
                                    } else {
                                        tools.getKey({
                                            id: data[key].id,
                                            client: client
                                        }).then(afterGetPk).catch(reject);
                                    }
                                    return;
                                }
                            }

                            /* Handle discriminator */
                        } else if (key === &quot;objectType&quot;) {
                            child = true;

                            /* Handle regular types */
                        } else {
                            value = data[key];
                            col = key.toSnakeCase();

                            // Handle objects whose values are actually strings
                            if (
                                prop.type === &quot;object&quot; &amp;&amp;
                                typeof value === &quot;string&quot; &amp;&amp;
                                value.slice(0, 1) !== &quot;[&quot;
                            ) {
                                value = &quot;\&quot;&quot; + value + &quot;\&quot;&quot;;
                            } else if (prop.type === &quot;array&quot;) {
                                value = JSON.stringify(value);
                            }

                            // Handle autonumber
                            if (
                                prop.autonumber &amp;&amp; (
                                    value === undefined || prop.isReadOnly
                                )
                            ) {
                                callback = function (err, resp) {
                                    let seq = resp.rows[0].seq - 0;

                                    if (err) {
                                        reject(err);
                                        return;
                                    }

                                    value = prop.autonumber.prefix || &quot;&quot;;
                                    value += seq.pad(prop.autonumber.length);
                                    value += prop.autonumber.suffix || &quot;&quot;;
                                    afterHandleRelations();
                                };

                                client.query(
                                    &quot;SELECT nextval($1) AS seq&quot;,
                                    [prop.autonumber.sequence],
                                    callback
                                );
                                return;
                            }

                            // Handle other types of defaults
                            if (value === undefined) {
                                if (
                                    prop.default !== undefined
                                ) {
                                    value = prop.default;
                                } else if (
                                    prop.format &amp;&amp;
                                    formats[prop.format] &amp;&amp;
                                    formats[prop.format].default !== undefined
                                ) {
                                    value = formats[prop.format].default;
                                } else {
                                    value = tools.types[prop.type].default;
                                }

                                // If we have a class specific default that
                                // calls a function
                                if (
                                    typeof value === &quot;string&quot; &amp;&amp;
                                    value.match(/\(\)$/)
                                ) {
                                    value = f[value.replace(/\(\)$/, &quot;&quot;)]();

                                    if (value.constructor.name === &quot;Promise&quot;) {
                                        Promise.all([value]).then(
                                            function (resp) {
                                                value = resp[0];
                                                afterHandleRelations();
                                            }
                                        ).catch(
                                            reject
                                        );
                                        return;
                                    }
                                }
                            }
                        }

                        afterHandleRelations();
                        return;
                    }

                    sql = (
                        &quot;INSERT INTO %I (_pk, &quot; + tokens.toString(&quot;,&quot;) +
                        &quot;) VALUES ($1,&quot; + params.toString(&quot;,&quot;) + &quot;);&quot;
                    );
                    sql = sql.format(args);

                    // Insert children first so notification gets full object
                    insertChildren();
                };

                afterGetPk = function (id) {
                    value = id;

                    if (value === undefined) {
                        msg = &quot;Relation not found in \&quot;&quot;;
                        msg += prop.type.relation;
                        msg += &quot;\&quot; for \&quot;&quot; + key + &quot;\&quot; with id \&quot;&quot;;
                        msg += data[key].id + &quot;\&quot;&quot;;
                        reject(new Error(msg));
                        return;
                    }

                    if (!isChild &amp;&amp; prop.type.childOf) {
                        msg = &quot;Child records may only be created from the&quot;;
                        msg += &quot; parent.&quot;;
                        reject(new Error(msg));
                        return;
                    }

                    afterHandleRelations();
                };

                afterHandleRelations = function () {
                    if (!child) {
                        if (prop.isRequired &amp;&amp; value === null) {
                            msg = &quot;\&quot;&quot; + key + &quot;\&quot; is required on &quot;;
                            msg += feather.name + &quot;.&quot;;
                            reject(new Error(msg));
                            return;
                        }

                        /* Handle non-relational composites */
                        if (
                            prop.type === &quot;object&quot; &amp;&amp;
                            prop.format === &quot;money&quot;
                        ) {
                            Object.keys(value || {}).forEach(function (attr) {
                                args.push(col);
                                args.push(attr.toSnakeCase());
                                tokens.push(&quot;%I.%I&quot;);
                                values.push(value[attr.toSnakeCase()]);
                                params.push(&quot;$&quot; + p);
                                p += 1;
                            });
                            buildInsert();
                            return;
                        }

                        /* Handle everything else */
                        args.push(col);
                        tokens.push(&quot;%I&quot;);
                        values.push(value);
                        params.push(&quot;$&quot; + p);
                        p += 1;
                    }

                    buildInsert();
                };

                insertChildren = function (err) {
                    let ckeys;

                    if (err) {
                        reject(err);
                        return;
                    }

                    // Get keys for properties of child arrays.
                    // Count expected callbacks along the way.
                    ckeys = Object.keys(props).filter(function (key) {
                        if (
                            typeof props[key].type === &quot;object&quot; &amp;&amp;
                            props[key].type.parentOf &amp;&amp;
                            data[key] !== undefined
                        ) {
                            clen += data[key].length;
                            return true;
                        }
                    });

                    // Insert children recursively
                    ckeys.forEach(function (key) {
                        let rel = props[key].type.relation;

                        data[key].forEach(function (row) {
                            row[props[key].type.parentOf] = {
                                id: data.id
                            };
                            crud.doInsert({
                                pk: pk,
                                name: rel,
                                data: row,
                                client: client
                            }, true).then(afterInsert).catch(reject);
                        });
                    });

                    afterInsert();
                };

                afterInsert = function () {
                    function afterParentInsert() {
                        // We&#x27;re done here if child
                        if (isChild) {
                            resolve(result);
                            return;
                        }

                        // Otherwise move on to log the change
                        crud.doSelect({
                            name: obj.name,
                            id: data.id,
                            client: client
                        }).then(afterDoSelect).catch(reject);
                    }

                    // Done only when all callbacks report back
                    c += 1;
                    if (c &lt; clen) {
                        return;
                    }

                    // Perform the parent insert
                    client.query(sql, values).then(
                        afterParentInsert
                    ).catch(
                        reject
                    );
                };

                afterDoSelect = function (resp) {
                    result = resp;

                    /* Handle change log */
                    crud.doInsert({
                        name: &quot;Log&quot;,
                        data: {
                            objectId: data.id,
                            action: &quot;POST&quot;,
                            created: data.created,
                            createdBy: data.createdBy,
                            updated: data.updated,
                            updatedBy: data.updatedBy,
                            change: f.copy(result)
                        },
                        client: client
                    }, true).then(afterLog).catch(reject);
                };

                afterLog = function () {
                    // We&#x27;re going to return the changes
                    result = jsonpatch.compare(obj.cache, result);

                    // Report back result
                    resolve(result);
                };

                // Kick off query by getting feather, the rest falls
                // through callbacks
                feathers.getFeather(payload).then(
                    afterGetFeather
                ).catch(
                    reject
                );
            });
        };

        /**
            Select records for an object based on payload id or an
            array of objects if no id provided.

            @method doSelect
            @param {Object} payload Request payload
            @param {String} [payload.id] Id of record to select
            @param {String} payload.name Name of feather
            @param {Object} [payload.filter] Filter criteria of records to
            select
            @param {String | Object} payload.client Database client
            @param {Boolean} [payload.showDeleted] include deleted records
            @param {Object} [payload.subscription] subscribe to events on
            results
            @param {Boolean} [payload.sanitize] sanitize result. Default true
            @param {Boolean} [isChild] Request as child. Default false.
            @param {Boolean} [isSuperUser] Request as super user. Default false.
            @return {Promise} Resolves to object or array.
        */
        crud.doSelect = function (obj, isChild, isSuperUser) {
            return new Promise(function (resolve, reject) {
                let sql;
                let table;
                let keys;
                let payload;
                let afterGetFeather;
                let afterGetKey;
                let afterGetKeys;
                let mapKeys;
                let tokens = [];
                let cols = [];
                let client = db.getClient(obj.client);

                payload = {
                    name: obj.name,
                    client: client,
                    showDeleted: obj.showDeleted
                };

                afterGetFeather = function (feather) {
                    if (!feather.name) {
                        reject(&quot;Feather \&quot;&quot; + obj.name + &quot;\&quot; not found.&quot;);
                        return;
                    }

                    table = &quot;_&quot; + feather.name.toSnakeCase();
                    keys = obj.properties || Object.keys(
                        feather.properties
                    );

                    /* Validate */
                    if (!isChild &amp;&amp; feather.isChild &amp;&amp; !isSuperUser) {
                        reject(&quot;Can not query directly on a child class&quot;);
                        return;
                    }

                    keys.forEach(function (key) {
                        tokens.push(&quot;%I&quot;);
                        cols.push(key.toSnakeCase());
                    });

                    cols.push(table);
                    sql = (
                        &quot;SELECT to_json((&quot; + tokens.toString(&quot;,&quot;) +
                        &quot;)) AS result FROM %I&quot;
                    );
                    sql = sql.format(cols);

                    /* Get one result by key */
                    if (obj.id) {
                        payload.id = obj.id;
                        tools.getKey(
                            payload,
                            isSuperUser
                        ).then(afterGetKey).catch(reject);

                        /* Get a filtered result */
                    } else {
                        payload.filter = obj.filter;
                        tools.getKeys(
                            payload,
                            isSuperUser
                        ).then(afterGetKeys).catch(reject);
                    }
                };

                afterGetKey = function (key) {
                    if (key === undefined) {
                        resolve(undefined);
                        return;
                    }

                    sql += &quot; WHERE _pk = $1&quot;;

                    client.query(sql, [key], function (err, resp) {
                        let result;

                        if (err) {
                            reject(err);
                            return;
                        }

                        result = mapKeys(resp.rows[0]);
                        if (obj.sanitize !== false) {
                            result = tools.sanitize(result);
                        }

                        resolve(result);
                    });
                };

                afterGetKeys = function (keys) {
                    let result;
                    let feathername;
                    let sort = (
                        obj.filter
                        ? obj.filter.sort || []
                        : []
                    );
                    let subscription = obj.subscription || {};
                    let i = 0;

                    if (keys.length) {
                        tokens = [];

                        while (keys[i]) {
                            i += 1;
                            tokens.push(&quot;$&quot; + i);
                        }

                        sql += &quot; WHERE _pk IN (&quot;;
                        sql += tokens.toString(&quot;,&quot;) + &quot;)&quot;;

                        tokens = [];
                        sql += tools.processSort(sort, tokens);
                        sql = sql.format(tokens);

                        client.query(sql, keys, function (err, resp) {
                            if (err) {
                                reject(err);
                                return;
                            }

                            result = tools.sanitize(resp.rows.map(mapKeys));

                            function ids(item) {
                                return item.id;
                            }

                            if (
                                !obj.filter || (
                                    !obj.filter.criteria &amp;&amp;
                                    !obj.filter.limit
                                )
                            ) {
                                feathername = obj.name;
                            }

                            // Handle subscription
                            events.subscribe(
                                client,
                                obj.subscription,
                                result.map(ids),
                                feathername
                            ).then(
                                function () {
                                    resolve(result);
                                }
                            ).catch(
                                reject
                            );
                        });
                    } else {
                        // Handle subscription
                        events.unsubscribe(
                            client,
                            subscription.id
                        ).then(
                            function () {
                                resolve([]);
                            }
                        ).catch(
                            reject
                        );
                    }
                };

                mapKeys = function (row) {
                    let rkeys;
                    let result = row.result;
                    let ret = {};
                    let i = 0;

                    if (typeof result === &quot;object&quot;) {
                        rkeys = Object.keys(result);
                        rkeys.forEach(function (key) {
                            ret[keys[i]] = result[key];
                            i += 1;
                        });

                        // If only one attribute returned
                    } else {
                        ret[keys[0]] = result;
                    }

                    return ret;
                };

                // Kick off query by getting feather, the rest falls through
                // callbacks
                feathers.getFeather({
                    client: client,
                    data: {
                        name: obj.name
                    }
                }).then(afterGetFeather).catch(reject);
            });
        };

        /**
            Update records based on patch definition.

            @method doUpdate
            @param {Object} payload Request payload
            @param {String} payload.id Id of record to update
            @param {Object} payload.data Patch to apply
            @param {String | Object} payload.client Database client
            @param {Boolean} [isChild] Request as child. Default false.
            @param {Boolean} [isSuperUser] Request as super user. Default
            false.
            @return {Promise} Resolves to array of patches reporting back
            differences between request and actual saved record result.
        */
        crud.doUpdate = function (obj, isChild, isSuperUser) {
            return new Promise(function (resolve, reject) {
                let result;
                let updRec;
                let props;
                let value;
                let sql;
                let pk;
                let relation;
                let key;
                let keys;
                let oldRec;
                let newRec;
                let cpatches;
                let feather;
                let tokens;
                let afterGetKey;
                let afterDoSelect;
                let afterUpdate;
                let afterSelectUpdated;
                let done;
                let nextProp;
                let afterProperties;
                let afterUniqueCheck;
                let unique;
                let doUnlock;
                let afterGetRelKey;
                let cacheRec;
                let patches = obj.data || [];
                let id = obj.id;
                let doList = [];
                let params = [];
                let ary = [];
                let clen = 0;
                let children = [];
                let p = 1;
                let n = 0;
                let client = db.getClient(obj.client);

                if (!patches.length) {
                    resolve([]);
                    return;
                }

                function find(ary, id) {
                    return ary.filter(function (item) {
                        return item &amp;&amp; item.id === id;
                    })[0] || false;
                }

                function noChildProps(key) {
                    if (
                        typeof feather.properties[key].type !== &quot;object&quot; ||
                        !feather.properties[key].type.childOf
                    ) {
                        return true;
                    }
                }

                function afterAuthorization(authorized) {
                    if (!authorized) {
                        reject(&quot;Not authorized to update \&quot;&quot; + id + &quot;\&quot;&quot;);
                        return;
                    }

                    tools.getKey({
                        id: id,
                        client: client
                    }).then(afterGetKey).catch(reject);
                }

                function afterGetFeather(resp) {
                    if (!resp) {
                        reject(&quot;Feather \&quot;&quot; + obj.name + &quot;\&quot; not found.&quot;);
                        return;
                    }

                    feather = resp;
                    tokens = [feather.name.toSnakeCase()];
                    props = feather.properties;

                    /* Validate */
                    if (!isChild &amp;&amp; feather.isChild) {
                        reject(&quot;Can not directly update a child class&quot;);
                        return;
                    }

                    if (isSuperUser === false) {
                        feathers.isAuthorized({
                            client: client,
                            data: {
                                id: id,
                                action: &quot;canUpdate&quot;
                            }
                        }).then(afterAuthorization).catch(reject);
                        return;
                    }

                    afterAuthorization(true);
                }

                afterGetKey = function (resp) {
                    pk = resp;
                    keys = Object.keys(props);

                    // Get existing record
                    crud.doSelect({
                        name: obj.name,
                        id: obj.id,
                        properties: keys.filter(noChildProps),
                        client: client,
                        sanitize: false
                    }, isChild).then(afterDoSelect).catch(reject);
                };

                afterDoSelect = function (resp) {
                    let eventKey = &quot;_eventkey&quot;; // JSLint no underscore
                    let msg;

                    function requiredIsNull(fkey) {
                        if (props[fkey].isRequired &amp;&amp; updRec[fkey] === null) {
                            key = fkey;
                            return true;
                        }
                    }

                    function uniqueChanged(fkey) {
                        let pf = props[fkey];

                        if (
                            pf.isNaturalKey &amp;&amp;
                            updRec[fkey] !== oldRec[fkey]
                        ) {

                            unique = {
                                feather: pf.inheritedFrom || feather.name,
                                prop: fkey,
                                value: updRec[fkey],
                                label: pf.alias || fkey
                            };

                            return true;
                        }
                    }

                    if (
                        oldRec &amp;&amp; oldRec.lock &amp;&amp;
                        oldRec.lock[eventKey] !== obj.eventkey
                    ) {
                        msg = &quot;Record is locked by &quot;;
                        msg += oldRec.lock.username;
                        msg += &quot; and cannot be updated.&quot;;
                        reject(new Error(msg));
                        return;
                    }

                    oldRec = tools.sanitize(resp);

                    if (!Object.keys(oldRec).length || oldRec.isDeleted) {
                        resolve(false);
                        return;
                    }

                    newRec = f.copy(oldRec);
                    jsonpatch.applyPatch(newRec, patches);

                    // Capture changes from original request
                    if (obj.cache) {
                        cacheRec = f.copy(oldRec);
                        jsonpatch.applyPatch(cacheRec, obj.cache);
                    }

                    if (!patches.length) {
                        afterUpdate();
                        return;
                    }

                    updRec = f.copy(newRec);

                    // Revert data that may not be updated directly
                    updRec.created = oldRec.created;
                    updRec.createdBy = oldRec.createdBy;
                    updRec.updated = new Date().toJSON();
                    updRec.updatedBy = client.currentUser();
                    updRec.isDeleted = false;
                    updRec.lock = oldRec.lock;

                    if (props.etag) {
                        updRec.etag = f.createId();
                    }

                    // Check required properties
                    if (keys.some(requiredIsNull)) {
                        reject(&quot;\&quot;&quot; + key + &quot;\&quot; is required.&quot;);
                        return;
                    }

                    // Check unique properties
                    if (keys.some(uniqueChanged)) {
                        tools.getKeys({
                            client: client,
                            name: unique.feather,
                            filter: {
                                criteria: [{
                                    property: unique.prop,
                                    value: unique.value
                                }]
                            }
                        }).then(afterUniqueCheck).catch(reject);
                        return;
                    }

                    // Process properties
                    nextProp();
                };

                afterUniqueCheck = function (resp) {
                    let msg;

                    if (resp &amp;&amp; resp.length) {
                        msg = &quot;Value &#x27;&quot; + unique.value + &quot;&#x27; assigned to &quot;;
                        msg += unique.label.toName() + &quot; on &quot;;
                        msg += feather.name.toName();
                        msg += &quot; is not unique to data type &quot;;
                        msg += unique.feather.toName() + &quot;.&quot;;
                        reject(new Error(msg));
                        return;
                    }

                    nextProp();
                };

                nextProp = function () {
                    let updProp;
                    let oldProp;
                    let msg;

                    key = keys[n];
                    n += 1;

                    if (n &lt;= keys.length) {
                        /* Handle composite types */
                        if (typeof props[key].type === &quot;object&quot;) {
                            updProp = updRec[key] || {};
                            oldProp = oldRec[key] || {};

                            /* Handle child records */
                            if (Array.isArray(updRec[key])) {
                                relation = props[key].type.relation;

                                /* Process deletes */
                                oldRec[key].forEach(function (row) {
                                    let cid = row.id;

                                    if (!find(updRec[key], cid)) {
                                        clen += 1;
                                        doList.push({
                                            func: crud.doDelete,
                                            payload: {
                                                name: relation,
                                                id: cid,
                                                client: client
                                            }
                                        });
                                    }
                                });

                                /* Process inserts and updates */
                                updRec[key].forEach(function (cNewRec) {
                                    if (!cNewRec) {
                                        return;
                                    }

                                    let cid = cNewRec.id || null;
                                    let cOldRec = find(oldRec[key], cid);

                                    if (cOldRec) {
                                        cpatches = jsonpatch.compare(
                                            cOldRec,
                                            cNewRec
                                        );

                                        if (cpatches.length) {
                                            clen += 1;
                                            doList.push({
                                                func: crud.doUpdate,
                                                payload: {
                                                    name: relation,
                                                    id: cid,
                                                    data: cpatches,
                                                    client: client
                                                }
                                            });
                                        }
                                    } else {
                                        cNewRec[props[key].type.parentOf] = {
                                            id: updRec.id
                                        };
                                        clen += 1;
                                        doList.push({
                                            func: crud.doInsert,
                                            payload: {
                                                name: relation,
                                                data: cNewRec,
                                                client: client
                                            }
                                        });
                                    }
                                });

                            /* Handle child relation updates */
                            } else if (props[key].type.isChild) {
                                /* Do delete */
                                if (oldRec[key] &amp;&amp; !updRec[key]) {
                                    crud.doDelete({
                                        name: props[key].type.relation,
                                        id: oldRec[key].id,
                                        client: client,
                                        isHard: true
                                    }, true, true).then(function () {
                                        afterGetRelKey(null, -1);
                                    }).catch(reject);

                                    return;
                                }

                                /* Do insert */
                                if (updRec[key] &amp;&amp; !oldRec[key]) {
                                    crud.doInsert({
                                        name: props[key].type.relation,
                                        id: updRec[key].id,
                                        data: updRec[key],
                                        client: client
                                    }, true, true).then(function () {
                                        tools.getKey({
                                            id: updRec[key].id,
                                            client: client
                                        }).then(
                                            afterGetRelKey
                                        ).catch(
                                            reject
                                        );
                                    }).catch(reject);

                                    return;
                                }

                                if (
                                    updRec[key] &amp;&amp; oldRec[key] &amp;&amp;
                                    updRec[key].id !== oldRec[key].id
                                ) {
                                    msg = &quot;Id cannot be changed on child&quot;;
                                    msg += &quot;relation &#x27;&quot; + key + &quot;&#x27;&quot;;
                                    reject(new Error(msg));
                                    return;
                                }

                                /* Do update */
                                cpatches = jsonpatch.compare(
                                    oldRec[key] || {},
                                    updRec[key] || {}
                                );

                                if (cpatches.length) {
                                    crud.doUpdate({
                                        name: props[key].type.relation,
                                        id: updRec[key].id,
                                        data: cpatches,
                                        client: client
                                    }, true, true).then(function () {
                                        tools.getKey({
                                            id: updRec[key].id,
                                            client: client
                                        }).then(
                                            afterGetRelKey
                                        ).catch(
                                            reject
                                        );
                                    }).catch(reject);
                                    return;
                                }

                                nextProp();
                                return;
                            }

                            /* Handle regular to one relations */
                            if (
                                !props[key].type.childOf &amp;&amp;
                                updProp.id !== oldProp.id
                            ) {

                                if (updProp.id) {
                                    tools.getKey({
                                        id: updRec[key].id,
                                        client: client
                                    }).then(afterGetRelKey).catch(reject);
                                } else {
                                    afterGetRelKey(null, -1);
                                }
                                return;
                            }

                            /* Handle non-relational composites */
                        } else if (
                            updRec[key] !== oldRec[key] &amp;&amp;
                            props[key].type === &quot;object&quot; &amp;&amp;
                            props[key].format === &quot;money&quot;
                        ) {

                            Object.keys(updRec[key]).forEach(
                                function (attr) {
                                    tokens.push(key.toSnakeCase());
                                    tokens.push(attr.toSnakeCase());
                                    ary.push(&quot;%I.%I = $&quot; + p);
                                    params.push(updRec[key][attr]);
                                    p += 1;
                                }
                            );

                            /* Handle regular data types */
                        } else if (
                            updRec[key] !== oldRec[key] &amp;&amp; key !== &quot;objectType&quot;
                        ) {

                            // Handle objects whose values are actually
                            // strings
                            if (
                                props[key].type === &quot;object&quot; &amp;&amp;
                                typeof updRec[key] === &quot;string&quot; &amp;&amp;
                                updRec[key].slice(0, 1) !== &quot;[&quot;
                            ) {
                                updRec[key] = &quot;\&quot;&quot; + value + &quot;\&quot;&quot;;
                            } else if (props[key].type === &quot;array&quot;) {
                                updRec[key] = JSON.stringify(updRec[key]);
                            }

                            tokens.push(key.toSnakeCase());
                            ary.push(&quot;%I = $&quot; + p);
                            params.push(updRec[key]);
                            p += 1;
                        }

                        nextProp();
                        return;
                    }

                    // Done, move on
                    afterProperties();
                };

                afterGetRelKey = function (resp) {
                    let msg;

                    value = resp;
                    relation = props[key].type.relation;

                    if (value === undefined) {
                        msg = &quot;Relation not found in \&quot;&quot;;
                        msg += relation + &quot;\&quot; for \&quot;&quot; + key;
                        msg += &quot;\&quot; with id \&quot;&quot; + updRec[key].id + &quot;\&quot;&quot;;
                        reject(new Error(msg));
                        return;
                    }

                    tokens.push(tools.relationColumn(key, relation));
                    ary.push(&quot;%I = $&quot; + p);
                    params.push(value);
                    p += 1;

                    nextProp();
                };

                afterProperties = function () {
                    // Execute child changes first so all captured in any
                    // notification
                    children = doList.map(
                        (item) =&gt; item.func(item.payload, true)
                    );

                    // Execute top level object change
                    sql = (
                        &quot;UPDATE %I SET &quot; + ary.join(&quot;,&quot;) +
                        &quot; WHERE _pk = $&quot; + p
                    );
                    sql = sql.format(tokens);
                    params.push(pk);
                    clen += 1;

                    Promise.all(children).then(
                        () =&gt; client.query(sql, params)
                    ).then(
                        afterUpdate
                    ).catch(
                        reject
                    );
                };

                afterUpdate = function () {
                    // If child, we&#x27;re done here
                    if (isChild) {
                        resolve();
                        return;
                    }

                    // If a top level record, return patch of what changed
                    crud.doSelect({
                        name: feather.name,
                        id: id,
                        client: client
                    }).then(afterSelectUpdated).catch(reject);
                };

                afterSelectUpdated = function (resp) {
                    result = resp;

                    // Handle change log
                    if (updRec) {
                        crud.doInsert({
                            name: &quot;Log&quot;,
                            data: {
                                objectId: id,
                                action: &quot;PATCH&quot;,
                                created: updRec.updated,
                                createdBy: updRec.updatedBy,
                                updated: updRec.updated,
                                updatedBy: updRec.updatedBy,
                                change: JSON.stringify(jsonpatch.compare(
                                    oldRec,
                                    result
                                ))
                            },
                            client: client
                        }, true).then(doUnlock).catch(reject);
                        return;
                    }
                    doUnlock();
                };

                doUnlock = function () {
                    crud.unlock(client, {
                        id: obj.id
                    }).then(
                        done
                    ).catch(
                        reject
                    );
                };

                done = function () {
                    // Remove the lock information
                    result.lock = null;

                    // Send back the differences between what user asked
                    // for and result
                    resolve(jsonpatch.compare(cacheRec, result));
                };

                // Kick off query by getting feather, the rest falls
                // through callbacks
                feathers.getFeather({
                    client: client,
                    data: {
                        name: obj.name
                    }
                }).then(afterGetFeather).catch(reject);
            });
        };

        /**
            Lock a record to prevent others from editing.

            @method lock
            @param {Object} client Database client connection id
            @param {String} nodeId Node id.
            @param {String} id Record id
            @param {String} username
            @param {String} eventKey
            @return {Promise} Resolves to &#x60;true&#x60; if successful.
        */
        crud.lock = function (client, nodeid, id, username, eventkey) {
            return new Promise(function (resolve, reject) {
                let msg;

                if (!nodeid) {
                    reject(new Error(&quot;Lock requires a node id.&quot;));
                    return;
                }

                if (!eventkey) {
                    reject(new Error(&quot;Lock requires an eventkey.&quot;));
                    return;
                }

                if (!id) {
                    reject(new Error(&quot;Lock requires an object id.&quot;));
                    return;
                }

                if (!username) {
                    reject(new Error(&quot;Lock requires a username.&quot;));
                    return;
                }

                function checkLock() {
                    return new Promise(function (resolve, reject) {
                        let sql = &quot;SELECT lock FROM object WHERE id = $1&quot;;

                        function callback(resp) {
                            if (!resp.rows.length) {
                                msg = &quot;Record &quot; + id + &quot; not found.&quot;;
                                reject(new Error(msg));
                                return;
                            }

                            if (resp.rows[0].lock) {
                                msg = &quot;Record &quot; + id + &quot; is already locked.&quot;;
                                reject(new Error(msg));
                                return;
                            }

                            resolve();
                        }

                        client.query(sql, [id]).then(
                            callback
                        ).catch(
                            reject
                        );
                    });
                }

                function doLock() {
                    return new Promise(function (resolve, reject) {
                        let params;
                        let sql;

                        sql = (
                            &quot;UPDATE object &quot; +
                            &quot;SET lock = ROW($1, now(), $2, $3) &quot; +
                            &quot;WHERE id = $4&quot;
                        );

                        function callback() {
                            resolve(true);
                        }

                        params = [
                            username,
                            nodeid,
                            eventkey,
                            id
                        ];

                        client.query(sql, params).then(
                            callback
                        ).catch(
                            reject
                        );
                    });
                }

                Promise.resolve().then(
                    checkLock
                ).then(
                    doLock
                ).then(
                    resolve
                ).catch(
                    reject
                );

            });
        };

        /**
            Unlock object(s) by type. At least one criteria must be provided.

            @method unlock
            @param {Object} client Database client connection id
            @param {Object} criteria Criteria for what to unlock.
            @param {String} [criteria.id] Object id.
            @param {String} [criteria.username] User name.
            @param {String} [criteria.eventKey] Browser instance key.
            @param {String} [criteria.nodeId] Node id.
            @return {Promise} Resolves to array of ids unlocked.
        */
        crud.unlock = function (client, criteria) {
            return new Promise(function (resolve, reject) {
                let sql;
                let params = [];

                function callback(resp) {
                    resolve(resp.rows);
                }

                sql = &quot;UPDATE object SET lock = NULL WHERE true &quot;;

                if (criteria.id) {
                    params.push(criteria.id);
                    sql += &quot; AND object.id = $1&quot;;
                }

                if (criteria.username) {
                    params.push(criteria.username);
                    sql += &quot; AND username(lock) = $&quot; + params.length;
                }

                if (criteria.eventKey) {
                    params.push(criteria.eventKey);
                    sql += &quot; AND _eventkey(lock) = $&quot; + params.length;
                }

                if (criteria.nodeId) {
                    params.push(criteria.nodeId);
                    sql += &quot; AND _nodeid(lock) = $&quot; + params.length;
                }

                if (!params.length) {
                    reject(new Error(&quot;No lock criteria defined.&quot;));
                    return;
                }

                sql += &quot; RETURNING id; &quot;;

                client.query(sql, params).then(
                    callback
                ).catch(
                    reject
                );
            });
        };

        return crud;
    };

}(exports));


    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
